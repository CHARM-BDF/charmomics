# CHARMomics Backend

CHARMomics' backend uses FastAPI as a Python REST endpoint framework to accept and process frontend and user requests.

It is currently used to interact with MongoDB for state management, a web accessible Swagger API documentation, and
to initate the annotation service when provided either a gene or variant to gather annotation data.

**Note:** There is also a RESTful backend service that provides access to an AI deployment, but it is only accessible
within UAB networks. The URL for the AI deployment can be swapped out for similar functionality if necessary.

## Setup

### Dependencies

- [Python 3.11](https://www.python.org/) - [Install](https://www.python.org/downloads/)
- [Pip](https://pip.pypa.io/en/{"originTabId":1,"originWindowId":1}stable/) - [Install](https://pip.pypa.io/en/stable/installation/)

### Local Development

To keep dependencies required for projects separate without changing global settings and packages we create
isolated virtual environments for these projects.

All packages necessary for CHARMomics development are installed into the `./backend/charmomics_env/` virtual
environment in the setup.sh script.

To create this isolation we use the python virtual environment [venv](https://docs.python.org/3.11/library/venv.html).
Refer to the python virtual environment for documentation.

To use in your shell, activate the virtual environment by running the following commands:

```bash
cd backend

python3 -m venv charmomics_env

source charmomics_env/bin/activate

pip3 install -r requirements.txt
```

## Linting

This project uses `pylint` as a linting tool.

Running the linter:

```bash
# From ./backend/

pylint src tests
```

## Formatting

The CHARMomics uses `yapf` to format the python codebase.
Configuration is maintained in `.style.yapf` within the `./backend` directory.

To recursively format all Python files in place, run the following

```bash
# From ./backend/

yapf -ir .
```

## Testing

The backend service uses `pytest` as a testing framework for the Python code. The tests are broken out into unit,
integration, and system tests.

Pytest notes:

- The `-s` flag for the pytest routes the standard out to the console. It allows the `print()` statement to log
output of variables for development purposes.

From the root `./backend` directory of the project:

Unit Tests:

```bash
pytest -s tests/unit
```

Integration Tests:

```bash
pytest -s tests/integration
```

### Code Coverage

Code coverage is generated by coverage.py using the pytest-cov package.  It was the easiest way to
setup code coverage for unit testing to use pytest-cov and its default configuration, then to
configure coverage.py directly.

The unit tests rely on the .coveragerc file to omit the 'main.py' where the application routes are stored.
'main.py' is tested by integration tests and not unit tests.

To view an HTML report of coverage, change the option of `--cov-report=term` to `--cov-report=html`.
Read <https://pytest-cov.readthedocs.io/en/latest/config.html> to learn more about pytest code coverage
tool configuration.

```bash
pytest --cov=src --cov-fail-under=80 --cov-branch --cov-report=term tests/unit/

pytest --cov=src --cov-fail-under=80 --cov-branch --cov-report=html tests/unit/
```
